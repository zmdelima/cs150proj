<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">

<link rel="import" href="shared-styles.html">

<dom-module id="simplex-solver">
  <template>
    <style include="shared-styles">
      :host {
        display: block;

        padding: 10px;
      }
      #functions_container input {
        margin: auto auto;
      }
      
      .constraint {
        width: 50vw;
        height: 20px;
      }
      #mode {
        background-color: white;
        color: black;
      }
      #addC {
        background-color: var(--paper-green-500);
        color: white;
      }
      .remove {
        background-color: var(--paper-red-900);
        color: white;
      }
      .ineq {
        background-color: white;
        color: black;
        width: 5%;
      }
    </style>

    <div class="card">
      <h1 id="page_title">Simplex Solver</h1>
      <div>
        <p>
        <h3>Instructions:</h3>
        1. Don't forget to choose to whether minimize or maximize 
        <br/>
        2. Fill out the objective function and the contraints that you would like to put
        <br/>
        3. Fill out the constraint function variables from "x1" to "xN" with N = number of variables with the "negated" RHS value
        <br/>
        4. Choose the inequality constraint
        <br/>
        5. Click Solve
        <br/>
        Example Constraint: 0 * x1 + -2.5 * x2 + 3.0 * x3 + -50
        </p>
      </div>
      
      Mode: <paper-button id="mode" on-click="changeMode" raised>MAXIMIZATION</paper-button>
      <br/>
      <h4>Objective Function</h4>
        <input id="objective"> = Z</input>
      <br/>
      <h4>Constraints:</h4> <paper-button id="addC" on-click="addConstraint" raised>ADD Constraint</paper-button>
      <div id="functions_container">
        <template id="fxn" is="dom-repeat" items="{{constraints}}" >
            <input value="{{item}}" class="constraint"></input><paper-button class="ineq" on-click="toggleIneq" value="0"><=</paper-button><paper-button class="remove" on-click="removeConstraint">REMOVE</paper-button>
        </template>
      </div>
      <paper-button on-click="solve">SOLVE</paper-button>
    </div>
  </template>
  <script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
  <script src="../bower_components/opencpu.js/opencpu-0.5.js"></script>
  <script>
    Polymer({
      is: 'simplex-solver',
      properties: {
       constraints: {
         type: Array,
         value: [],
         notify: true,
         reflectToAttribute: true
       } 
      },
      hurry: function(){
        console.log("HURRY!");
      },
      ready: function(){
        this.hurry();
      },
      changeMode : function(){
        if (this.root.querySelector('#mode').innerHTML == "MAXIMIZATION") {
          this.root.querySelector('#mode').setAttribute('style',`background-color: black; color: white;`);
          this.root.querySelector('#mode').innerHTML = "MINIMIZATION";
        } else {
          this.root.querySelector('#mode').setAttribute('style',`background-color: white; color: black;`);
          this.root.querySelector('#mode').innerHTML = "MAXIMIZATION";
        }
      },
      toggleIneq :function(e) {
        console.log("ineq!");
        console.log(e.target);
        if (e.target.getAttribute('value') == 0) {
          console.log('<=');
          e.target.setAttribute('style',`background-color: black; color: white;`);
          e.target.innerHTML = ">=";
          e.target.setAttribute('value',1);
        } else {
          e.target.setAttribute('style',`background-color: white; color: black;`);
          e.target.innerHTML = "<=";
          e.target.setAttribute('value',0);
        }
      },
      addConstraint : function(){
        this.constraints.push("");
        this.root.querySelector('#fxn').render();
      },
      getChildIndex : function(child){
        var parent = child.parentNode;
        var children = parent.children;
        var i = children.length - 1;
        for (; i >= 0; i--){
            if (child == children[i]){
                break;
            }
        }
        return i;
      },
      removeConstraint : function(e){
        console.log('removing Constraint');
        console.log(this.constraints);
        console.log(e.target.parentNode.childNodes);
        var index = this.getChildIndex(e.target);
        console.log(index);
        this.constraints.splice((Math.floor((index+1)/2)-1),1);
        this.root.querySelector('#fxn').render();
      },
      negateFunc : function(equation){
        var func = equation.split(" ");
        console.log(func);
        for(var i=0; i<func.length; i++){
          if(!isNaN(parseFloat(func[i]))) {
            func[i] = (((parseFloat(func[i])*-1)*10)/10).toString();
            
          }
        }
        equation = func.join(" ");
        console.log('negated equation');
        console.log(equation);
        return equation;
      },
      countVar : function(equation){
        return equation.split("x").length-1;
      },
      solve : function(){
        var conts = this.root.querySelectorAll(".constraint");
        if(conts.length == 0) {
          window.alert("There are no Constraints!");
          return;
        }
        this.constraints = [];
        for (var i=0; i<conts.length; i++) {
          if(conts[i].value == "") {
            window.alert("Please put input in constraint "+(i+1)+" or delete the constraint if it is really empty");
            return;
          }
          this.constraints[i] = conts[i].value;
        }
        
        var prev_count = this.countVar(this.root.querySelector("#objective").value);
        var var_count = 0;
        for (var i=0; i<conts.length; i++) {
          var_count = this.countVar(conts[i].value);
          if(prev_count != var_count) {
            window.alert("Incorrect number of variables in constraint "+(i+1));
            return;
          }
          prev_count = var_count;
        }
        
        //creating linear sys
        var ineqs = this.root.querySelectorAll(".ineq");
        var mode = (this.root.querySelector('#mode').innerHTML == "MAXIMIZATION") ? 0 : 1;
        for (i=0; i<ineqs.length; i++) {
          if (ineqs[i].getAttribute('value') == 1) {
            if(mode == 0) {
              this.constraints[i] = this.negateFunc(this.constraints[i]);
            }
          } else {
            if(mode == 1) this.constraints[i] = this.negateFunc(this.constraints[i]);
          }
        }
        
        console.log("constraints");
        console.log(this.constraints);
        
        var ls = [];
        var variables = "";
        for(var j=0; j<var_count; j++){
            variables += "x"+(j+1).toString();
            if(j+1 != var_count) {
              variables +=",";
            }
          }
        for (i=0; i<this.constraints.length; i++) {
          ls[i] = "E"+(i+1).toString()+"<- function(";
          ls[i] += variables;
          ls[i] += ") "+this.constraints[i];
        }
        
        console.log("linsys")
        var joinls = ls.join("; ") + "; ";
        joinls += "E"+(this.constraints.length+1)+"<- function("+variables+") "+this.root.querySelector('#objective').value;
        console.log('LINEAR SYSTEEEMS');
        console.log(joinls);
        
        var sys = " sys<- list(";
        for (i=0; i<ineqs.length+1; i++) {
          sys += "E" + (i+1).toString();
          if(i+1 != ineqs.length+1){
            sys +=",";
          }
        }
        sys +=")";
        
        console.log('sys');
        console.log(sys);
        var mode = (this.root.querySelector('#mode').innerHTML == "MAXIMIZATION") ? 0 : 1;
        var simplexscr = "  AugCoeffMatrix <- function(system) {     equation <- NULL;     pos <- NULL;     ing <- NULL;     variables <- NULL;     for (i in seq(1, length(system), by=1)) {              current <- unlist(system[i]);       current <- deparse(current);              for (x in seq(2, length(current), by=1)) {         equation <- paste(equation, current[x], sep=\"\");       };       current = equation;       equation = NULL;              substr(current, nchar(current), nchar(current)) = \" \";              current <- strsplit(current, \"\\\\s+\");       current <- unlist(current);                     for (y in seq(1, length(current), by=1)) {         if (is.na(as.numeric(current[y]))) {           current[y] <- \"\";         } else {           break;         };       };       variableIndex = grep(\"x\", current);                     if (i > 1) {         if (csize != length(variableIndex)+1) {         };       };              csize <- length(variableIndex)+1;              for (x in seq(1, length(variableIndex), by=1)) {         pos[length(pos)+1] = as.numeric(substr(current[variableIndex[x]], 2, 3));       };              for (x in seq(1, length(variableIndex), by=1)) {         ing[length(ing)+1] = as.numeric(current[variableIndex[pos[x]]-2]);       };       for (x in seq(2, length(current), by=1)) {         if (substr(current[x], 1, 1) != \"x\") {           if (x == length(current)) {             ing[length(ing)+1] = current[x];           } else if (grepl(\"\\\\+\", current[x+1])) {              ing[length(ing)+1] = current[x];           };         };       };                     pos = c();     };          ing <- as.numeric(ing);          for (i in seq(csize, length(ing), by=csize)) {       ing[i] = ing[i] * -1;     };          mat = matrix(c(ing), nrow=length(system), ncol=csize, byrow=TRUE);          for (i in seq(1, csize-1, by=1)) {       variables[length(variables)+1] = paste(\"x\", i, sep=\"\");     };               rownames(mat) <- 1:length(system);     colnames(mat) <- c(variables, \"RHS\");          return(list(variables=variables, augcoeffmatrix=mat));        };      Simplex <- function(x,mode) {     mat <- AugCoeffMatrix(x)$augcoeffmatrix;     matrix <- mat;     iter <- 0;     compilation <- NULL;     x <- NULL;     if(mode == 1){       matrix <- t(mat);     };          matrix[nrow(matrix),] = matrix[nrow(matrix),] * -1;     matrix = cbind(matrix[ , 1:ncol(matrix)-1], diag(nrow(matrix)), matrix[ , ncol(matrix)]);     compilation[[1]] = matrix;     for(iter in seq(1, 10000,by=1)){       minCol <- which.min(matrix[nrow(matrix),]);       if(matrix[nrow(matrix),minCol] >= 0) {         return (compilation);       };       pCol <- matrix[,minCol];       rhsCol <- matrix[,ncol(matrix)];       rowVal <- rhsCol / pCol;       rowVal <- rowVal[1:length(rowVal)-1];              minRow <- which(rowVal == min(rowVal[which(rowVal > 0)]));       matrix[minRow,] = matrix[minRow,] / matrix[minRow,minCol];       for(i in seq(1,nrow(matrix),by=1)){         if(length(minRow) == 0) return (list());         if(i == minRow) next;         if(length(matrix[i,]) != length(matrix[i,] - (matrix[i,minCol]*matrix[minRow,]))) return (list());         matrix[i,] = matrix[i,] - (matrix[i,minCol]*matrix[minRow,]);       };       compilation[[iter+1]] = matrix;     };   };";
        simplexscr += joinls+";"+sys+"; Simplex(sys,"+mode+");";
        console.log(simplexscr)
        var newSnippet = new ocpu.Snippet(simplexscr);
        ocpu.seturl("//public.opencpu.org/ocpu/library/base/R");
        var req = ocpu.rpc("identity", {
            "x" : newSnippet
        }, function(session){
          console.log("RScript output");
          console.log(session);
          if(session.length != 0) {
            
          }
          else {
            window.alert("Infeasible objective function and constraints combination")
          }
        }.bind(this));
      }
    });
  </script>
</dom-module>
